//
// INSTRUCTIONS
//
// Given a word, write a function to generate all of its unique generalized abbreviations.

// A generalized abbreviation of a word can be generated by replacing each substring of the word
// with the count of characters in the substring.Take the example of “ab” which has four
// substrings: “”, “a”, “b”, and “ab”. After replacing these substrings in the actual word by the
// count of characters, we get all the generalized abbreviations: “ab”, “1b”, “a1”, and “2”.

// Note: All contiguous characters should be considered one substring, e.g., we can’t
// take “a” and “b” as substrings to get “11”; since “a” and “b” are contiguous, we should
// consider them together as one substring to get an abbreviation “2”.

//
// EXAMPLE
//
// Input: "BAT"
// Output: "BAT", "BA1", "B1T", "B2", "1AT", "1A1", "2T", "3"
//
// Input: "code"
// Output: "code", "cod1", "co1e", "co2", "c1de", "c1d1", "c2e", "c3", "1ode", "1od1", "1o1e", "1o2", "2de", "2d1", "3e", "4"
//

//
// PREPARATION
//
class Abbr {
   constructor(str, charPos, skipCount) {
      this.str = str;
      this.charPos = charPos;
      this.skipCount = skipCount;
   }
}

//
// CODE
//
function generate_generalized_abbreviation(word) {
   // return recursiveSolution(word, "", [], 0, 0);
   //
   // OR
   //
   const stack = [new Abbr("", 0, 0)];
   const result = [];

   while (stack.length > 0) {
      const abbr = stack.shift();
      if (abbr.charPos === word.length) {
         // reached the last char - append the abbrviation into resulting abbrs array
         let newAbbr = abbr.str;
         if (abbr.skipCount > 0) {
            newAbbr += abbr.skipCount;
         }
         result.push(newAbbr);
      } else {
         // abbreviating - concate the abbr, counter and cuttent char and restart the abbreviation
         let newAbbr = abbr.str;
         if (abbr.skipCount > 0) {
            newAbbr += abbr.skipCount;
         }
         newAbbr += word[abbr.charPos];
         stack.push(new Abbr(newAbbr, abbr.charPos + 1, 0));

         // skipping - continue by increasing character position and skip counts
         stack.push(new Abbr(abbr.str, abbr.charPos + 1, abbr.skipCount + 1));
      }
   }

   return result;
}

function recursiveSolution(word, abbr, result, charPos, skipCount) {
   if (charPos === word.length) {
      // reached the last char - append the abbrviation into resulting abbrs array
      let newAbbr = abbr;
      if (skipCount > 0) {
         newAbbr += skipCount;
      }
      result.push(newAbbr);
   } else {
      // abbreviating - concate the abbr, counter and cuttent char and restart the abbreviation
      let newAbbr = abbr;
      if (skipCount > 0) {
         newAbbr += skipCount;
      }
      newAbbr += word[charPos];
      recursiveSolution(word, newAbbr, result, charPos + 1, 0);

      // skipping - continue by increasing character position and skip counts
      recursiveSolution(word, abbr, result, charPos + 1, skipCount + 1);
   }

   return result.join(", ");
}

//
// TEST
//
console.log(generate_generalized_abbreviation("BAT"));
console.log(generate_generalized_abbreviation("CODE"));

//
// COMPLEXITY ANALYSIS
//
// Since we had two options for each character, we will have a maximum of 2^N combinations. If you see the
// visual representation of Example - 1 closely, you will realize that it is equivalent to a binary tree,
// where each node has two children.This means that we will have 2^N leaf nodes. While processing each
// element, we do need to concatenate the current string with a character.This operation will take O(N),
// so the overall time complexity of our algorithm will be O(N * 2^N)
//
// All the additional space used by our algorithm is for the output list. Since we can’t have more than
// 2^N combinations, the space complexity of our algorithm is O(N * 2^N).
//
